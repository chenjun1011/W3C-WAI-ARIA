# <a id="host_languages"></a>7. Implementation in Host Languages

This section is [normative](#def_normative).

The [roles](#def_role), [states](#def_state), and [properties](#def_property) defined in this specification do not form a complete web language or format. They are intended to be used in the context of a host language. This section discusses how host languages are to implement WAI-ARIA, to ensure that the markup specified here will integrate smoothly and effectively with the host language markup.

Although markup languages look alike superficially, they do not share language definition infrastructure. To accommodate differences in language-building approaches, the requirements are both general and modularization-specific. While allowing for differences in how the specifications are written, the intent is to maintain consistency in how the WAI-ARIA information looks to authors and how it is manipulated in the DOM by scripts.

WAI-ARIA roles, states, and properties are implemented as [attributes](#def_attribute) of [elements](#def_element). Roles are applied by placing their names among the tokens appearing in the [value](#def_value) of a host-language-provided `role` attribute. States and properties each get their own attribute, with values as defined for each particular state or property in this specification. The name of the attribute is the aria-prefixed name of the state or property.

## <a id="host_general_role"></a>7.1. Role Attribute

An implementing host language will provide an [attribute](#def_attribute) with the following characteristics:

* The attribute name **MUST** be `role`;
* The attribute [value](#def_value) **MUST** allow a token list as the value;
* The appearance of the name literal of any concrete WAI-ARIA [role](#def_role) as one of these tokens **MUST NOT** in and of itself make the attribute value illegal in the host-language syntax; and
* The first name literal of a non-abstract WAI-ARIA role in the list of tokens in the role attribute defines the role according to which the user agent **MUST** process the element. User Agent processing for roles is defined in the [WAI-ARIA User Agent Implementation Guide](http://www.w3.org/TR/2014/REC-wai-aria-implementation-20140320/) \[[ARIA-IMPLEMENTATION](#ref_ARIA-IMPLEMENTATION)\].

## <a id="host_general_attrs"></a>7.2. State and Property Attributes

An implementing host language **MUST** allow [attributes](#def_attribute) with the following characteristics:

* The attribute name is the name of any state or property identified in the [Supported States and Properties](#states_and_properties) section, such as `aria-busy`, `aria-selected`, `aria-activedescendant`, `aria-valuetext`;
* The syntax does **NOT** prevent the attribute from appearing anywhere that it is applicable, as specified in this specification;
* When these attributes appear in a document instance, the attributes will be processed as defined in this specification.

Host languages that support [XML Namespaces](http://www.w3.org/TR/2006/REC-xml-names-20060816/) \[[XML-NAMES](#ref_XML-NAMES)\] **MAY** require that WAI-ARIA attributes be used with a namespace. In this case, the namespace for WAI-ARIA state and property attributes **MUST** be `http://www.w3.org/ns/wai-aria/`. To use WAI-ARIA in host languages that do not explicitly describe support for it, authors **SHOULD** use this namespace as well, if the host language supports namespaces and there is expectation that user agents will recognize the WAI-ARIA namespace. The namespace prefix is not defined by this specification but generally is expected to be "`aria`". 

> Note: The WAI-ARIA state and property attributes have a naming convention such that they all begin with the string "`aria-`". This is _not_ a namespace prefix, it is a part of the state or property name. Therefore, when using WAI-ARIA states and properties with namespace prefixes, the complete attribute name will be like "`aria:aria-foo`".

Some host languages do not use namespaces with WAI-ARIA state and property attributes, either because the host language does not support namespaces or because the designers wish to incorporate WAI-ARIA into the core feature set. In these host languages, the namespace name for these attributes has no value. The names of these attributes do not have a prefix offset by a colon; in the terms of namespaces they are unprefixed attribute names. The ECMAScript binding of the DOM interface `getAttributeNS` for example, treats an empty string (`""`) as representing this condition, so that both `getAttribute("aria-busy")` and `getAttributeNS("", "aria-busy")` access the same [`aria-busy`](#aria-busy) attribute in the DOM.

> Note: According to the requirements of this section, some user agents recognize WAI-ARIA state and property attributes _with_ namespaces, some _without_ namespaces, and some might recognize both. Authors are advised to be aware of which form is supported for the host language they are using. Unless the host language and supporting user agents explicitly indicate that the namespace is required, authors are advised to use the attribute without namespaces. Even user agents that support namespaces generally do not publish namespaced WAI-ARIA states and properties to accessibility APIs. In particular, current implementations of HTML, including XHTML, do not support this namespace.

## <a id="host_general_focus"></a>7.3. Focus Navigation

An implementing host language **MUST** provide support for the author to make all interactive elements focusable, that is, any renderable or event-receiving elements. An implementing host language **MUST** provide a facility to allow web authors to define whether these focusable, interactive elements appear in the default tab navigation order. The `tabindex` [attribute](#def_attribute) in HTML 5 is an example of one implementation.

## <a id="implicit_semantics"></a>7.4. Implicit WAI-ARIA Semantics

WAI-ARIA is designed to provide [semantic](#def_semantics) information about objects when host languages lack native semantics for the object. WAI-ARIA is designed, however, to provide additional semantics for many host languages. Furthermore, host languages over time can evolve and provide new native features that correspond to WAI-ARIA features. Therefore, there are many situations in which WAI-ARIA semantics are redundant with host language semantics. 

These host language features can be viewed as having "implicit WAI-ARIA semantics". User agent processing of features with implicit WAI-ARIA semantics would be similar to the processing for the WAI-ARIA feature. The processing might not be identical because of lexical differences between the host language feature and the WAI-ARIA feature, but generally the user agent would expose the same information to the accessibility API. Features with implicit WAI-ARIA semantics satisfy WAI-ARIA structural requirements such as required owned elements, required states and properties, etc. and do not require explicit WAI-ARIA semantics to be provided.

For example, if an element with the functionality already exists, such as a checkbox or radio button, use the native semantics of the host language. WAI-ARIA markup is only intended to be used to enhance the native semantics (e.g., indicating that the element is required with [`aria-required`](#aria-required)), or to change the semantics to a different purpose form the standard functionality of the element.

Implicit WAI-ARIA semantics affect the conflict resolution procedures in the following section, Conflicts with Host Language Semantics. Therefore, implicit WAI-ARIA semantics need to be defined in a normative specification, such as the host language specification or the [WAI-ARIA User Agent Implementation Guide](http://www.w3.org/TR/2014/REC-wai-aria-implementation-20140320/) \[[ARIA-IMPLEMENTATION](#ref_ARIA-IMPLEMENTATION)\].

## <a id="host_general_conflict"></a>7.5. Conflicts with Host Language Semantics

WAI-ARIA roles, states, and properties are intended to add [semantic](#def_semantics) information when native host language elements with these semantics are not available, and are generally used on elements that have no native semantics of their own. They can also be used on elements that have similar but non-identical semantics (for example, a nested list could be used to represent a tree structure). This method can be part of a fallback strategy for older browsers that have no WAI-ARIA implementation, or because native presentation of the repurposed element reduces the amount of style and/or script needed. Except for the cases outlined below, user agents **MUST** always use the WAI-ARIA semantics to define how it exposes the element to accessibility APIs, rather than using the host language semantics.

In addition to these normal situations in which WAI-ARIA is expected to override native semantics, there are elements that are inappropriate to override with WAI-ARIA. This could be because identical host language semantics exist, so WAI-ARIA is not needed, or because semantics from WAI-ARIA directly conflict with host language semantics. When a feature in the host language with identical role semantics and values is available, and the author has no compelling reason to avoid using the host language feature, authors **SHOULD** use the host language features rather than repurpose other elements with WAI-ARIA.

Host languages can have features that have implicit WAI-ARIA semantics corresponding to roles. When a WAI-ARIA role is provided, user agents **MUST** use the semantic of the WAI-ARIA role for processing, not the native semantic, unless the role requires WAI-ARIA states and properties whose attributes are explicitly forbidden on the native element by the host language. Values for roles do not conflict in the same way as values for states and properties (for example, the HTML 'checked' attribute and the 'aria-checked' attribute could have conflicting values), and authors are expected to have valid reason to provide a WAI-ARIA role even on elements that would not normally be repurposed.

When WAI-ARIA states and properties correspond to host language features that have the same [implicit WAI-ARIA semantic](#implicit_semantics), it can be particularly problematic to use the WAI-ARIA feature. If the WAI-ARIA feature and the host language feature are both provided but their values are not kept in sync, user agents and assistive technologies cannot know which value to use. Therefore, to prevent providing conflicting states and properties to assistive technologies, host languages **MUST** explicitly declare where the use of WAI-ARIA attributes on each host language element conflicts with native attributes for that element. When a host language declares a WAI-ARIA attribute to be in direct semantic conflict with a native attribute for a given element, user agents **MUST** ignore the WAI-ARIA attribute and instead use the host language attribute with the same implicit semantic.

Host languages **MAY** document features that cannot be overridden with WAI-ARIA (these are called "strong native semantics"). These can be features that have implicit WAI-ARIA semantics, as well as features where the processing would be uncertain if the semantics were changed with WAI-ARIA. Conformance checkers **MAY** signal an error or warning when a WAI-ARIA role is used on elements with strong native semantics, but as described above, user agents **MUST** still use the value of the the semantic of the WAI-ARIA role when exposing the element to accessibility APIs.

## <a id="state_property_processing"></a>7.6. State and Property Attribute Processing

State and property attributes are included in host languages, and therefore syntax for representation of their value types is governed by the host language. For each of the value types defined in [Value](#propcharacteristic_value), an appropriate value type from the host language is used. Recommended correspondences between WAI-ARIA value types and various host language value types are listed in [Mapping WAI-ARIA Value types to languages](#typemapping). This is a non-normative mapping in order to accommodate new host languages supporting WAI-ARIA.

The list value types—ID reference list and token list—allow more than one value of the given type to be provided. The values are separated by delimiter characters recognized by the host language for list attributes, such as space characters, commas, etc. Some languages may require a specific, single delimiter, while others may allow various delimiters.

Global states and properties are supported on any element in the host language. However, authors **MUST** only use non-global states and properties on elements with a role supporting the state or property; either defined as an explicit WAI-ARIA role, or as defined by the host language semantic matching an appropriate WAI-ARIA role. When a role attribute is added to an element, the [semantics](#def_semantics) and behavior of the element, including support for WAI-ARIA states and properties, are augmented or overridden by the role behavior. User agents **MUST** ignore non-global states and properties used on an element without a role supporting the state or property; either defined as an explicit WAI-ARIA role, or as defined by the host language semantic matching an appropriate WAI-ARIA role. For example, the [`aria-valuetext`](#aria-valuetext) attribute may be used on a [`progress`](http://www.w3.org/TR/html-markup/progress.html) element in HTML, without requiring the author to explicitly and redundantly specify the role as [`progressbar`](#progressbar).

When WAI-ARIA roles are used, supported states and properties that are not present in the DOM are treated according to their default value, unless they are required. For token states and properties, an attribute value that is a zero-length string ("") also corresponds to the default value. Therefore, user agents **SHOULD** treat token state and property attributes with a value of "" the same as they treat an absent attribute. Normally this corresponds to the default value (usually "undefined"), but if it is a required attribute, they signal an error (because a null value is the same as failing to provide the required attribute).